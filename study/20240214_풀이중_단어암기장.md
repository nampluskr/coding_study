### [풀이중] 단어암기장

```cpp
#include <queue>
using namespace std;

#define MAX_WORDS   50001
#define MAX_ROWS    20000       // (5 ≤ N ≤ 20,000)
#define MAX_COLS    10000       // (5 ≤ M ≤ 1,000)
#define INF         0x7fffffff
#define MAX_BLOCKS  141         // sqrt(00)
#define ERASED      1

struct Word {
    int row, col, len, state;
};
Word words[MAX_WORDS];
int wordCnt;

struct Position {
    int col, len;
    bool operator<(const Position& pos) const { return col > pos.col; }
};

struct Row {
    priority_queue<Position> Q;
    int maxLen;

    void update() {
        maxLen = 0;
        vector<Position> popped;
        while (!Q.empty()) {
            auto cur = Q.top(); Q.pop();
            while (!Q.empty() && cur.col + cur.len == Q.top().col) {
                cur.len += Q.top().len;
                Q.pop();
            }
            maxLen = max(maxLen, cur.len);
            popped.push_back(cur);
        }
        for (auto& cur : popped) { Q.push(cur); }
    }
    void push(const Position& pos) { 
        Q.push(pos);
    }
    Position get_position(int mLen) {
        Position res = { -1, -1 };
        vector<Position> popped;
        while (!Q.empty()) {
            auto cur = Q.top(); Q.pop();
            if (cur.len >= mLen) { res = cur; break; }
            else { popped.push_back(cur); }
        }
        for (auto& cur : popped) { Q.push(cur); }
        return res;
    }
};
Row rows[MAX_ROWS];

struct Block {
    int idx, maxlen;
};

struct Partition {
    Block blocks[MAX_BLOCKS];
    int bSize, bCnt;
    int num_values;

    void init(int N) {
        num_values = N;
        bSize = sqrt(num_values);
        bCnt = ceil((double)num_values / bSize);
        for (int i = 0; i < bCnt; i++) { blocks[i] = {}; }
    }
    void updatePoint(int idx, int value) {
        int bIdx = idx / bSize;
        int left = bIdx * bSize;
        int right = min((bIdx + 1) * bSize - 1, num_values - 1);

        if (idx == blocks[bIdx].idx) {
            blocks[bIdx].maxlen = -INF;
            for (int i = left; i <= right; i++) {
                if (blocks[bIdx].maxlen < rows[i].maxLen)
                    blocks[bIdx] = { i, rows[i].maxLen };
            }
        }
        else if (blocks[bIdx].maxlen < value)
            blocks[bIdx] = { idx, value };
    }
    int get_block(int mLen) {
        for (int i = 0; i < bCnt; i++)
            if (blocks[i].maxlen >= mLen)
                return i;
        return -1;
    }
    int get_row(int mLen) {
        int bIdx = get_block(mLen);
        if (bIdx != -1) {
            int left = bIdx * bSize;
            int right = min((bIdx + 1) * bSize - 1, num_values - 1);

            for (int i = left; i <= right; i++)
                if (rows[i].maxLen >= mLen)
                    return i;
        }
        return -1;
    }
};
Partition P;

/////////////////////////////////////////////////////////////////////
void init(int N, int M)
{
    wordCnt = 0;
    for (int i = 0; i < MAX_WORDS; i++) { words[i] = {}; }

    P.init(N);
    for (int i = 0; i < N; i++) {
        rows[i].push({ 0, M });
        rows[i].update();
        P.updatePoint(i, rows[i].maxLen);
    }
}

int writeWord(int mId, int mLen)
{
    int row = P.get_row(mLen);
    if (row == -1) return -1;

    wordCnt = mId;
    auto pos = rows[row].get_position(mLen);
    rows[row].update();
    P.updatePoint(row, rows[row].maxLen);

    words[mId] = { row, pos.col, pos.len - mLen };

    if (pos.len > mLen) {
        rows[row].push({ pos.col + mLen, pos.len - mLen });
        rows[row].update();
        P.updatePoint(row, rows[row].maxLen);
    }
    return row;
}

int eraseWord(int mId)
{

    return -1;
}
```
